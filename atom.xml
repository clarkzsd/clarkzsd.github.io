<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clark&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhoushidong.cc/"/>
  <updated>2017-10-24T05:13:35.596Z</updated>
  <id>http://zhoushidong.cc/</id>
  
  <author>
    <name>Clark Zhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 异步编程一二三</title>
    <link href="http://zhoushidong.cc/2017/10/23/understanding-async-JavaScript/"/>
    <id>http://zhoushidong.cc/2017/10/23/understanding-async-JavaScript/</id>
    <published>2017-10-23T09:35:16.000Z</published>
    <updated>2017-10-24T05:13:35.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JavaScript-天生异步"><a href="#1-JavaScript-天生异步" class="headerlink" title="1. JavaScript 天生异步"></a>1. JavaScript 天生异步</h2><blockquote><p>你说我一个浏览器写写表单验证的，怎么就突然成为如今最流行的编程语言了呢？</p></blockquote><p>JavaScript 设计之初是用于浏览器端 GUI 编程，这就决定了这门语言是单线程、非阻塞的。而 JavaScript 正是通过异步执行任务来实现非阻塞。</p><p>关于 JavaScript 异步机制和 Event loop 详细可见：<a href="http://vimeo.com/96425312" target="_blank" rel="noopener">Help, I’m stuck in an event-loop</a></p><h2 id="2-异步函数的类型"><a href="#2-异步函数的类型" class="headerlink" title="2. 异步函数的类型"></a>2. 异步函数的类型</h2><p>JavaScript 环境本身提供的异步函数通常可以分为两大类：</p><ol><li>I/O 函数</li><li>计时函数</li></ol><p>如果想在应用中自定义复杂的异步任务，就需要在两类异步函数上构建。</p><h2 id="3-异步解决方案"><a href="#3-异步解决方案" class="headerlink" title="3. 异步解决方案"></a>3. 异步解决方案</h2><h3 id="3-1-回调"><a href="#3-1-回调" class="headerlink" title="3.1 回调"></a>3.1 回调</h3><p>一开始，JS 中的异步是通过回调实现的。如果想让某段代码将来执行，可以将它放在一个回掉函数中。例如下面的 node 代码，只有在文件读取完毕后，<code>&#39;finished&#39;</code>才会被打印。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, (err, result) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finished'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是随着应用变得复杂，我们有许多异步事件需要处理，并且需要数据从一个事件传递到下一个事件，那么回调函数就会变得这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">step1(<span class="function"><span class="keyword">function</span>(<span class="params">result1</span>) </span>&#123;</span><br><span class="line">step2(<span class="function"><span class="keyword">function</span>(<span class="params">result2</span>) </span>&#123;</span><br><span class="line">        step3(<span class="function"><span class="keyword">function</span>(<span class="params">result3</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样的代码被称为<code>Callback Hell</code>（回调地狱），回调地狱主要以下有以下几大罪状</p><ol><li><p>代码丑陋，不符合人类阅读习惯</p></li><li><p>异常难以捕获</p><p><code>try/catch</code>是同步代码，上面的 step 函数运行时，<code>try/catch</code>已经执行完毕，异常并不能被捕获。</p></li><li><p>代码容易产生冗余</p><p>假设我们还有一个不同的操作需要在 step1 之后完成，那么得再来一段<code>Callback Hell</code>了……</p></li></ol><h3 id="3-2-Pub-Sub"><a href="#3-2-Pub-Sub" class="headerlink" title="3.2 Pub/Sub"></a>3.2 Pub/Sub</h3><p>Pub/Sub(发布/订阅)模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p><p>我觉得 Pub/Sub 模式和蝴蝶效应很像：某个事件被触发，整个应用都受到影响。</p><p>Pub/Sub 模式可以很好的解决回调地狱产生的代码冗余的问题。</p><p>DOM 事件就是很典型的 Pub/Sub 模式。例如下面的点击事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'the button is clicked'</span>); </span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>这里我们相当于订阅了<code>button</code>上面的点击事件，当用户点击之后，这个按钮就会向订阅者发布这个消息。</p><h3 id="3-3-Promise"><a href="#3-3-Promise" class="headerlink" title="3.3  Promise"></a>3.3  Promise</h3><p>事件（click, keyup）和 Pub/Sub 模式对于同一对象上发生多次的事情非常有用，但是关系到异步事件执行的成功或者失败，Pub/Sub 模式没有提供一个好的解决方案。Promise 很好的解决了这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设`ready()`返回一个 Promise.</span></span><br><span class="line">img.ready().then(<span class="function">(<span class="params">result</span>)=&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'success!'</span>); &#125;, (err) =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">'failed!'</span>); &#125;)</span><br></pre></td></tr></table></figure><p>当然，Promise 在异步事件执行方面的优点不仅于此。</p><p>Promise 最早由社区提出和实现，常见的 Promise 的第三方库有</p><ul><li><a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">Q</a></li><li><a href="https://github.com/cujojs/when" target="_blank" rel="noopener">when</a></li><li><a href="https://msdn.microsoft.com/en-us/library/windows/apps/br211867.aspx" target="_blank" rel="noopener">WinJS</a></li><li><a href="https://github.com/tildeio/rsvp.js" target="_blank" rel="noopener">RSVP.js</a></li></ul><p>而官方则在 ES6 正式支持 Promise，并采用了 <a href="https://github.com/promises-aplus/promises-spec" target="_blank" rel="noopener">Promises/A+</a> 规范。</p><p>Promise 为什么叫 Promise 呢，我觉得 MDN 上面关于 Promise 的中文“翻译”很好的解释了这一点🙃：</p><blockquote><p><strong>Promise </strong>对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义：诺言，一个成功，一个失败。)</p><p>原文：</p><p>The <strong>Promise</strong> object represents the eventual completion (or failure) of an asynchronous operation, and its resulting value.</p></blockquote><p>Promise 通过链接多个<code>then()</code>来处理多个异步操作，比回掉地狱优雅很多：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aPromiseStuff().then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doPromiseStuff();</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doAnotherPromiseStuff();</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于 Promise 的更多内容可以查看 MDN 上面的教程：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a></p><p>还有两篇关于 Promise 的文章很值得一读：</p><ul><li><a href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="noopener">We have a problem with promises</a></li><li><a href="https://developers.google.com/web/fundamentals/primers/promises" target="_blank" rel="noopener">JavaScript Promises: an Introduction</a></li></ul><h3 id="3-4-Generator"><a href="#3-4-Generator" class="headerlink" title="3.4 Generator"></a>3.4 Generator</h3><p>Generator Function 和 Generator 也是 ES6 引入的新特性。</p><p><code>function*</code>这种声明方式用来定义一个 Generator Function，后者会返回一个 Generator 对象。</p><p>当一个 Generator Function 被调用时并不会马上执行；相反，它会返回一个 Generator 对象。每次调用 Generator 对象的<code>next()</code>方法将会执行函数至下一个<code>yield</code>表达式，并返回一个符合迭代器协议的对象，包含<code>value</code>和<code>done</code>两个属性。<code>value</code>的值为<code>yield</code>表达式的运行结果，函数运行结束时其值为<code>undefined</code>；<code>done</code>的值表示函数是否运行结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">simpleGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"first"</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"second"</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"third"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = simpleGenerator();</span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; value: "first", done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; value: "second", done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; value: "third", done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; value: 0, done: false &#125;,</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; value: 1, done: false &#125;,</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; value: 1, done: false &#125;,</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; value: undefined, done: true &#125;,</span></span><br></pre></td></tr></table></figure><p>Generator Function 这种可以暂停执行和恢复执行的特性，使它能够有处理异步任务的能力。可是光有一个 Generator Function 还不够，它还需要有一个执行器来执行它所封装的异步任务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">1</span>)</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">handleAsynchronousStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> val = <span class="keyword">yield</span> doSomething();</span><br><span class="line">      <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>万事具备，只欠一个<a href="https://github.com/tj/co" target="_blank" rel="noopener">co</a>:</p><blockquote><p>co:</p><p>Generator based control flow goodness for nodejs and the browser, using promises, letting you write non-blocking code in a nice-ish way.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line">co(handleAsynchronousStuff) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>我们再来看看 co 做了什么事:</p><p><img src="http://o6ljw8wcq.bkt.clouddn.com/blog/co.png" alt="co 示意图"></p><p>co 的功能其实不算复杂，总共也就 200 多行代码。它不断递归拆解 generator function 中的 yield 表达式，并返回一个 Promise。它做的事情就是执行用 Generator 封装好的异步任务。</p><h4 id="Generator-错误处理"><a href="#Generator-错误处理" class="headerlink" title="Generator 错误处理"></a>Generator 错误处理</h4><p>generator 对象有一个 throw 方法，可以在 generator function 外面抛出异常，并且能够在 generator function 中使用<code>try/catch</code>捕获异常，详细内容可见 MDN 文档：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw" target="_blank" rel="noopener">Generator.prototype.throw()</a></p><p>那么，使用 Generator 处理异步任务可以优雅的捕获异常吗？答案是肯定的，我们再来啃一啃 co 的核心函数的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we wrap everything in a promise to avoid promise chaining,</span></span><br><span class="line">  <span class="comment">// which leads to memory leak errors.</span></span><br><span class="line">  <span class="comment">// see https://github.com/tj/co/issues/180</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.apply(ctx, args);</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line"></span><br><span class="line">    onFulfilled();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;Mixed&#125; res</span></span><br><span class="line"><span class="comment">     * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="comment">     * @api private</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.next(res);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;Error&#125; err</span></span><br><span class="line"><span class="comment">     * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="comment">     * @api private</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.throw(err);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the next value in the generator,</span></span><br><span class="line"><span class="comment">     * return a promise.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param &#123;Object&#125; ret</span></span><br><span class="line"><span class="comment">     * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="comment">     * @api private</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// generator function 执行完毕，Promise 状态变为 resolve</span></span><br><span class="line">      <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br><span class="line">      <span class="comment">// value =&gt; Promise</span></span><br><span class="line">      <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</span><br><span class="line">      <span class="comment">// 如果 value 成功转变为 Promise，则通过`Promise.then()`继续拆解 generator function，并为Promise 添加`onFulfilled`和`onRejected`</span></span><br><span class="line">      <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">      <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></span><br><span class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它对 generator function 的异常处理封装在了 <code>onRejected()</code>函数当中：如果发生错误，则将返回的 Promise 的状态变为<code>reject</code>，再调用<code>next()</code>继续拆解 generator function。</p><p>通过 co 的处理，异步函数中的异常成功通过<code>gen.throw()</code>抛出，那么我们就可以跟同步代码一样使用<code>try/catch</code>捕获异常了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            reject(<span class="string">'something is wrong'</span>)</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">handleAsynchronousStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> val = <span class="keyword">yield</span> doSomething();</span><br><span class="line">      <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Error: '</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(handleAsynchronousStuff); <span class="comment">// Error: something is wrong</span></span><br></pre></td></tr></table></figure><p>嗯……不得不说 Generator 使异步处理的过程更加优雅了。但是 Generator 本身并不是专门用来处理异步任务的，而且在使用 Generator 这种方案时，还得引入第三方模块 co，总觉得有点变扭。</p><p>ES7：那就来个语法糖把它们包装一下吧！</p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>ES7 正式引入<code>async/await</code>，它本质上就是 Generator 解决方案的语法糖，并且内置了执行器，上面的<code>handleAsynchronousStuff()</code>可以这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleAsynchronousStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> val = <span class="keyword">await</span> doSomething();</span><br><span class="line">      <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Error: '</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleAsynchronousStuff();</span><br></pre></td></tr></table></figure><p>我觉得<code>async/await</code>相较于 Promise 的最直观的优点就是代码的可阅读性大大的提高了。在过去，我们需要链式地写<code>then()</code>来处理<code>Promise()</code>的<code>resolve</code>值，逻辑一复杂，嵌套的代码就越来越多，而<code>async/await</code>则让我们可以像写同步代码一样来写异步代码。</p><p><img src="http://o6ljw8wcq.bkt.clouddn.com/blog/504.jpg" alt=""></p><p>关于<code>async/await</code>与<code>Promise</code>更详细的对比，可以见这篇文章：</p><ul><li><a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" target="_blank" rel="noopener">6 Reasons Why JavaScript’s Async/Await Blows Promises Away</a></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>说到底，<code>async/await</code>就是基于 <code>Promise</code>和<code>Generator</code>的，要用好<code>async/await</code>，就必须先理解<code>Promise</code>和<code>Generator</code>。</p><p>这篇文章正是在阐述这样一个观点：在使用<code>async/await</code>之前，先理解<code>Promise</code></p><ul><li><a href="https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8" target="_blank" rel="noopener">Understand promises before you start using async/await</a></li></ul><p>说来惭愧，再还没有真正理解<code>Promise</code>和<code>Generator</code>之前我就已经在跟风使用<code>async/await</code>了，如今正是在恶补 JavaScript 异步解决方案的发展历程。现在再来看<code>async/await</code>，发现 JavaScript 这门语言的发展有很大一部分都是依赖于开源社区的贡献，不得不感叹开源社区的力量之强大。</p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《JavaScript 异步编程：设计快速响应的网络应用》</li><li><a href="http://taobaofed.org/blog/2016/03/18/error-handling-in-koa/" target="_blank" rel="noopener">如何优雅地在 koa 中处理错误</a></li><li>MDN</li></ul><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul><li><a href="https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8" target="_blank" rel="noopener">Understand promises before you start using async/await</a></li><li><a href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="noopener">We have a problem with promises</a></li><li><a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" target="_blank" rel="noopener">6 Reasons Why JavaScript’s Async/Await Blows Promises Away</a></li><li><a href="https://developers.google.com/web/fundamentals/primers/promises" target="_blank" rel="noopener">JavaScript Promises: an Introduction</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-JavaScript-天生异步&quot;&gt;&lt;a href=&quot;#1-JavaScript-天生异步&quot; class=&quot;headerlink&quot; title=&quot;1. JavaScript 天生异步&quot;&gt;&lt;/a&gt;1. JavaScript 天生异步&lt;/h2&gt;&lt;blockquote
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhoushidong.cc/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>理解 JWT</title>
    <link href="http://zhoushidong.cc/2017/09/29/understanding-JWT/"/>
    <id>http://zhoushidong.cc/2017/09/29/understanding-JWT/</id>
    <published>2017-09-29T15:03:39.000Z</published>
    <updated>2017-09-30T12:04:52.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JWT-简介"><a href="#JWT-简介" class="headerlink" title="JWT 简介"></a>JWT 简介</h2><p>JWT(JSON Web Token) 是一个基于 JSON 的<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">开放标准</a>，它允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。</p><p>JWT 本质上就是一串字符串，它由</p><ol><li>Header</li><li>Payload</li><li>Signature</li></ol><p>这三个部分组成，每个部分之间使用<code>.</code>进行分隔。</p><p>关于 JWT 的更多介绍可见 <a href="https://jwt.io/introduction/" target="_blank" rel="noopener">https://jwt.io/introduction/</a></p><p><img src="http://o6ljw8wcq.bkt.clouddn.com/blog/JWT.png" alt="jwt"></p><h2 id="JWT-使用流程"><a href="#JWT-使用流程" class="headerlink" title="JWT 使用流程"></a>JWT 使用流程</h2><p><img src="https://cdn.auth0.com/content/jwt/jwt-diagram.png" alt="jwt-diagram"></p><p>整个流程图很清晰明朗，但是在第三步和第四步之间，客户端是需要保存用户状态的，那么JWT 是如何存储在客户端的呢？</p><h2 id="浏览器端-JWT-存储方案"><a href="#浏览器端-JWT-存储方案" class="headerlink" title="浏览器端 JWT 存储方案"></a>浏览器端 JWT 存储方案</h2><h3 id="1-HTML5-WebStorage-localStorage-or-sessionStorage"><a href="#1-HTML5-WebStorage-localStorage-or-sessionStorage" class="headerlink" title="1. HTML5 WebStorage:  localStorage or sessionStorage"></a>1. HTML5 WebStorage:  localStorage or sessionStorage</h3><p>使用这种方案时，服务端一般将<code>token</code>放入<code>response body</code>中发送给客户端：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line">&#123;</span><br><span class="line">  "token":"eyJhbGciOiJIUzI1R5cCIpXVCJ9.eyJpZCI6MSwiZW1W4MIjcwMDk2fQ.aYC_idpEATBit6QmOiNSTn_SY8v0o"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>localStorage 和 sessionStorage 是 HTML5 的特性，使用起来非常简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'token'</span>, response.body.token);</span><br></pre></td></tr></table></figure><h3 id="2-Cookie-Storage"><a href="#2-Cookie-Storage" class="headerlink" title="2. Cookie Storage"></a>2. Cookie Storage</h3><p>Cookie 的工作机制是用户识别及状态管理。调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路径、协议等有效信息，所以正规发布的 Cookie 内的数据不会因来自其他站点和攻击者的攻击而泄露。为 Cookie 服务的 HTTP header 有以下两种：</p><table><thead><tr><th>字段名</th><th>说明</th><th>header 字段类型</th></tr></thead><tbody><tr><td>Set-Cookie</td><td>开始状态管理所使用的 Cookie 信息</td><td>响应字段</td></tr><tr><td>Cookie</td><td>服务端接收到的 Cookie 信息</td><td>请求字段</td></tr></tbody></table><p>验证用户信息成功后，服务端会将 JWT 放在HTTP header 中的<code>Set-Cookie</code>字段</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Set-Cookie</span>: access_token=eyJhbGciOiJIUzI1R5cCIpXVCJ9.eyJpZCI6MSwiZW1W4MIjcwMDk2fQ.aYC_idpEATBit6QmOiNSTn_SY8v0o; Secure; HttpOnly;</span><br></pre></td></tr></table></figure><p>这样一来，当客户端向服务端发送请求时，请求中的<code>Cookie</code>字段会包含从服务端接收到的<code>Cookie</code>。</p><h3 id="Which-one-is-better？"><a href="#Which-one-is-better？" class="headerlink" title="Which one is better？"></a>Which one is better？</h3><p>使用 WebStorage 存储<code>token</code>，那么任何运行在该网站上的 JS 代码都可以访问到<code>token</code>。如果网站遭到 XSS 攻击，那么用户信息就变得不安全了。所以包括 White Hat 在内的很多组织都建议不要将一些重要信息存储在 localStorage 和 sessionStorage 中。另外，在传输用户信息和 JWT 的过程中，数据也不是安全的，所以最好能将 Web 应用的升级成 HTTPS，使用 SSL 对通信进行加密。</p><p>使用<code>HttpOnly</code>属性的 cookie，是无法被 JS 代码获取的。同时，给 Cookie 增加<code>Secure</code>属性还可以确保 cookie 只能通过 HTTPS 传输。JWT 具有自包含的特性，所以携带 JWT 的 cookie 无需在服务端存储，开发者不必担心使用 cookie 会破坏 RESTful 的最佳实践。但是面对 CSRF 攻击，Cookie 也能被恶意窃取。默认情况下，无法通过 HTTP 跨域发送 cookie，若要跨域，需在<code>Access-Control-Allow-Origin</code>字段中指定明确的域名。</p><p>关于这两种方案的比较，这篇文章做了比较全面的描述：<a href="https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage" target="_blank" rel="noopener">Where to Store Your Jwts</a></p><h3 id="通过-Authorization-Header-将发送-JWT"><a href="#通过-Authorization-Header-将发送-JWT" class="headerlink" title="通过 Authorization Header 将发送 JWT"></a>通过 Authorization Header 将发送 JWT</h3><p>若使用 WebStorage 作为存储方案，那么就需要 JWT 就需要通过<code>Authorization</code>头字段来发送。Authorization 由两部分组成</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Authorization</span>: &lt;type&gt; &lt;credentials&gt;</span><br></pre></td></tr></table></figure><p>type 指的是验证类型，常见的有以下几种：</p><ul><li><strong>Basic</strong> (see <a href="http://tools.ietf.org/html/7617" target="_blank" rel="noopener">RFC 7617</a>, base64-encoded credentials.),</li><li><strong>Bearer</strong> (see <a href="http://tools.ietf.org/html/6750" target="_blank" rel="noopener">RFC 6750</a>, bearer tokens to access OAuth 2.0-protected resources),</li><li><strong>Digest</strong> (see <a href="http://tools.ietf.org/html/7616" target="_blank" rel="noopener">RFC 7616</a>, only md5 hashing is supported in Firefox, see <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=472823" target="_blank" rel="noopener">bug 472823</a>for SHA encryption support),</li><li><strong>HOBA</strong> (see <a href="http://tools.ietf.org/html/7486" target="_blank" rel="noopener">RFC 7486</a> (draft), HTTP Origin-Bound Authentication, digital-signature-based),</li></ul><p>每个验证类型的不同之处在于它们的适用范围（客户端类型和服务端类型），以及它们的加密强度。</p><p>根据RFC，传输 JWT 选择的 Bearer 类型。JWT 与 类型之间以空格分隔。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Authorization</span>: Bearer eyJhbGciOiJIUzI1R5cCIpXVCJ9.eyJpZCI6MSwiZW1W4MIjcwMDk2fQ.aYC_idpEATBit6QmOiNSTn_SY8v0o; Secure; HttpOnly;</span><br></pre></td></tr></table></figure><h2 id="Use-JWT-or-not"><a href="#Use-JWT-or-not" class="headerlink" title="Use JWT  or not ?"></a>Use JWT  or not ?</h2><p>在 JWT 之前，人们往往是通过 cookie + session 的方式来解决服务器如何识别用户的问题:</p><p><img src="http://o6ljw8wcq.bkt.clouddn.com/blog/session-cookie.png" alt="cookie-session"></p><p>通过比较可以看出，使用 JWT 可以省去服务端读取 Session 的操作，它可以充分依赖无状态 API，更加符合 RESTful 规范。</p><p>看起来，JWT 十分美好。</p><p>但是！综合来看，还是有其局限性，已经有人呼吁停止将 JWT 用于会话机制。</p><p><a href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/" target="_blank" rel="noopener">Stop using jwt for sessions</a>这篇文章将 JWT 的优劣分析的很详尽，也说明了 JWT 的真正使用场景。</p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ol><li><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">JWT introduction</a></li><li><a href="https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage" target="_blank" rel="noopener">Where to Store Your Jwts</a></li><li><a href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/" target="_blank" rel="noopener">Stop using jwt for sessions</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JWT-简介&quot;&gt;&lt;a href=&quot;#JWT-简介&quot; class=&quot;headerlink&quot; title=&quot;JWT 简介&quot;&gt;&lt;/a&gt;JWT 简介&lt;/h2&gt;&lt;p&gt;JWT(JSON Web Token) 是一个基于 JSON 的&lt;a href=&quot;https://tools
      
    
    </summary>
    
    
      <category term="HTTP" scheme="http://zhoushidong.cc/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>取模和取余的区别以及 JS 中的取模运算问题</title>
    <link href="http://zhoushidong.cc/2017/08/18/mod-vs-rem/"/>
    <id>http://zhoushidong.cc/2017/08/18/mod-vs-rem/</id>
    <published>2017-08-18T09:26:08.000Z</published>
    <updated>2017-09-10T02:51:20.692Z</updated>
    
    <content type="html"><![CDATA[<h3 id="取模-VS-取余"><a href="#取模-VS-取余" class="headerlink" title="取模 VS 取余"></a>取模 VS 取余</h3><p>取模运算（Modulo Operation）属于计算机术语，运算符为<code>%</code>。取余运算（Complementation ）就是平常数学运算中的求余数。它们两个概念有重叠的部分但又不完全一致。</p><p>先来看看除法运算中求余数的整个过程，a、b、c 和 d 分别为被除数、除数、商和被除数。</p><ol><li>求商：c = a / b;</li><li>求模或者余数：r =  a - c * b;</li></ol><p>取模和取余的区别体现在第一步：取余运算在求 c 时，向 0 方向舍弃小数位；取模运算则向<code>-∞</code>方向舍弃小数位。所以，当a 和 b 中其一为负数时，取模和取余的运算结果就不同了。例如：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">9 </span>/ (-<span class="number">4</span>) = -<span class="number">2.25</span></span><br></pre></td></tr></table></figure><p>取余运算就会把 c 取做 -2 ，运算结果为 1；取模运算则把 c 取做 -3，运算结果为 -3；</p><h3 id="JS-中的"><a href="#JS-中的" class="headerlink" title="JS 中的%"></a>JS 中的<code>%</code></h3><p>一般来讲，计算机语言中的<code>%</code>运算符代表的都是取模运算，然而在 JavaScript 中，<code>%</code>代表的是取余运算。</p><p><img src="http://o6ljw8wcq.bkt.clouddn.com/blog/mod.png" alt="node 环境下的 % 运算和 python 环境下的 % 运算"></p><p>所以，在写 JS 时遇到这个问题不要慌，这不是个 bug，而是个 feature……</p><h3 id="在-JS-中进行取模运算："><a href="#在-JS-中进行取模运算：" class="headerlink" title="在 JS 中进行取模运算："></a>在 JS 中进行取模运算：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.mod = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="keyword">this</span> % n) + n) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ol><li><a href="https://stackoverflow.com/questions/4467539/javascript-modulo-not-behaving#comment43942831_4467539" target="_blank" rel="noopener">Stackoverflow:javascript-modulo-not-behaving</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;取模-VS-取余&quot;&gt;&lt;a href=&quot;#取模-VS-取余&quot; class=&quot;headerlink&quot; title=&quot;取模 VS 取余&quot;&gt;&lt;/a&gt;取模 VS 取余&lt;/h3&gt;&lt;p&gt;取模运算（Modulo Operation）属于计算机术语，运算符为&lt;code&gt;%&lt;/cod
      
    
    </summary>
    
      <category term="Tech" scheme="http://zhoushidong.cc/categories/Tech/"/>
    
    
      <category term="JavaScript" scheme="http://zhoushidong.cc/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>《云图》———今夜我们聊聊人类</title>
    <link href="http://zhoushidong.cc/2017/08/04/Cloud-Atlas/"/>
    <id>http://zhoushidong.cc/2017/08/04/Cloud-Atlas/</id>
    <published>2017-08-04T09:47:24.000Z</published>
    <updated>2017-08-04T13:57:54.009Z</updated>
    
    <content type="html"><![CDATA[<p>说来惭愧，《云图》这本书是我高二买的，然而我在大二结束时才刚刚读完。</p><p>读完书的当天，我立刻把电影《云图》给看完了。很早就想看《云图》这部电影，但是一直憋着打算等到看完原著再去看电影，觉得这样无论是阅读体验还是观影体验都会好点。电影的完整版片长有172分钟，然后当时在中国上映的时候被剪成了134分钟。同样，今年的《迷失Z城》国内版也被剪了将近40分钟。这里只是举两个引进版本删减相对严重的例子。对电影的删减是严重影响观影体验的，关于这个话题不多谈，只希望国内能早日建立起电影分级制度。</p><p>《云图》这本书的叙事很特别。从19世纪到后末日未来，六个故事，六个主人公……《云图》是史诗没错，但从整体上来看，它的宏大叙事很与众不同。这六个故事不是按照时间顺序一一排列，而是按照按1-2-3-4-5-6-5-4-3-2-1排列。它以19世纪 Adam Ewing 的故事为开头，也是以 Adam Ewing 的故事结尾，像一个闭环。</p><p><img src="http://o6ljw8wcq.bkt.clouddn.com/blog/2017-8-4/TIM%E5%9B%BE%E7%89%8720170804193739.jpg" alt="目录"></p><p>说实话，《云图》中的每个故事单独拿出来并不是特别吸引人，这也许是我读这这本书这么长时间的原因之一……但是读完之后你还是能与作者想表达的思想产生共鸣的。六个故事时间跨度很大，但是彼此之间相互联系。作者将这种联系具象化为胎记与云图六重奏。这里谈谈六个主人公的相同彗星胎记。胎记这个东西最直观的寓意就是他们是 related 的，或者说他们就是同一个人。但是，他们的性格、他们的经历又各不相同，具象化的表现就是他们的胎记在不同的位置。所以我觉得作者是想要表达的是，不同时代的他们看似毫不相同，但他们的行为导致了他们的命运存在某种程度上的殊途同归。</p><p>所以，宏观来看，他们的故事可以归纳为人类的故事，他们所处的时代人类历史上可能经历过好几次。当然，Sonmi 并不是真正的人类，但她却是那个时代的革命者，最后又被人类奉为神明。这是一个很有意思的地方。</p><p>有时候我觉得，作者就是处在一个上帝视角一边审视人类一边写着这本书的。</p><p>虽然说六个主人公所处不同的时代，但可以说他们的故事对我们来讲并不陌生：宗教与信仰、压迫与反抗、对真理的追寻、人性的复杂、生死离别、文明的陨落……太阳底下并无新鲜事，这些破烂事天天在人类身上发生，无论时代怎么变，人类还是人类，人性亘古不变。</p><blockquote><ul><li><p>Meronym：没错，前辈们的智慧征服了疾病，跨越了距离，插下了种子，但是它没有征服一件东西。人类心中的渴望，不，一种永无休止的渴望。</p></li><li><p>Zachry Bailey：渴望是什么？我问。前辈们拥有一切。</p></li><li><p>Meronym ：更多的能量，对。那时候整个世界很大，但是对于这种渴望还不够强烈。这种渴望让前辈们冲破天空，让海洋沸腾，用疯狂的原子毒化土壤，顽固地播撒腐烂的种子，于是孕育了新的灾难，小孩生下来都是怪胎。最后，令人心痛的是，很快，国家分裂成野蛮的部落，文明时代结束，仅有一些边边角角的地方还闪亮着最后一丝余火。</p><p>——《云图·思想刹路口及之后所有》</p></li></ul></blockquote><p><strong>以上是后末日时代 Zachry Bailey 与 Meronym 的对话，仿佛是对现实世界的警示。人类现在就在做他们对话中的事。</strong></p><p>这六个故事中，我最喜欢 Timothy Cavendish 逃出养老院的经历。作者用黑色幽默的笔法写了一个发生在现代的（21世纪初）追求自由的故事。读一段时，我觉得这个故事的基调很符合现代生活，似乎现代人的的确确就是生活在一个充满黑色幽默的世界。Timothy Cavendish 的生活丧到不行，人已年迈，但他仍然在努力摆脱生活窘境。想必他逃出养老院的那一刻会吟着 Dylan Thomas 的<code>Do not go gentle into that good night</code>吧。</p><p><img src="http://o6ljw8wcq.bkt.clouddn.com/blog/2017-8-4/runaway.png" alt=""></p><p><strong>这是逃出养老院后，Timothy Cavendish 朋友们的对话</strong></p><p>看完电影，我不得不说这本书真的不适合改编成电影。电影对书中的情节倒是复现的挺完整的，但是把六个故事塞进一部电影还是会显得电影过于冗长与臃肿，尽管导演使用了许多艺术加工手段。再者，多条故事线来回切换难以会让没看过原著的观众感到不知所云。</p><p>但是，电影也有电影的优势。电影是以动态图像的方式在叙事，它的情感表现力是绝对超过文字的。影片结尾，主人公们都在历史上（至少是自己的历史上）画上了浓墨重彩的一笔，Because human nature is just like this .蒙太奇式的剪辑将「Robert Frobisher 的自杀、Sonmi 的处刑、Adam Ewing 带着妻子与他的岳父分道扬镳、Luisa Rey 与 Javier Gomez 庆祝胜利、Timothy Cavendish 与初恋共度晚年」衔接起来，加上恰到好处的配乐，最后的情感高潮给人带来极大的艺术享受与情感共鸣。这种震撼光读文字是无法体会得到的。或许这就是电影的魅力所在吧。</p><p>当然，他们的故事我们能感同身受的真正原因是我们也在经历与他们相同的故事，他们和我们都是波澜壮阔的云图的一部分。或许我们的身上也印着彗星状的胎记。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说来惭愧，《云图》这本书是我高二买的，然而我在大二结束时才刚刚读完。&lt;/p&gt;
&lt;p&gt;读完书的当天，我立刻把电影《云图》给看完了。很早就想看《云图》这部电影，但是一直憋着打算等到看完原著再去看电影，觉得这样无论是阅读体验还是观影体验都会好点。电影的完整版片长有172分钟，然后
      
    
    </summary>
    
    
      <category term="读书" scheme="http://zhoushidong.cc/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="电影" scheme="http://zhoushidong.cc/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>The First Encounter With Socket</title>
    <link href="http://zhoushidong.cc/2017/04/26/The-First-Encounter-With-Socket/"/>
    <id>http://zhoushidong.cc/2017/04/26/The-First-Encounter-With-Socket/</id>
    <published>2017-04-26T12:42:09.000Z</published>
    <updated>2017-04-26T16:04:41.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络基础-TCP-IP"><a href="#网络基础-TCP-IP" class="headerlink" title="网络基础 TCP/IP"></a>网络基础 TCP/IP</h2><p>在讨论 Socket 之前，我们得先追本溯源，看看 TCP/IP 是什么。</p><p>计算机与网络设备之间的通信，就如大国之间的外交一样，需要一种规则。这种规则就成称为协议（protocol）。计算机网络协议中存在各种各样的内容：从电缆规格到 IP 地址的选定方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。</p><p>而与互联网相关联的协议集合总称为 TCP/IP。</p><h3 id="TCP-IP-的分层"><a href="#TCP-IP-的分层" class="headerlink" title="TCP/IP 的分层"></a>TCP/IP 的分层</h3><p>TCP/IP 按层次分为4层：应用层、传输层、网络层和数据链路层。</p><table><thead><tr><th>layer</th><th>detail</th></tr></thead><tbody><tr><td>应用层</td><td>应用层决定了向用户提供应用服务时通信的活动。TCP/IP协议族内预存了各类通用的应用服务。比如 FTP （File Transfer Protocol ）、HTTP、和DNS（Domain Name System）。</td></tr><tr><td>传输层</td><td>传输层提供处于网络连接中的两台计算机之间的数据。在传输层有两个性质不同的协议：TCP（Transmission Control Protocol）和 UDP （User Data Protocol）</td></tr><tr><td>网络层</td><td>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小单位。该层规定了到达对方计算机的传输路线，并把数据包传送给对方。</td></tr><tr><td>链路层</td><td>用来处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动，NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分。</td></tr></tbody></table><h3 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP/IP 通信传输流"></a>TCP/IP 通信传输流</h3><p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信，发送端从应用层往下走，接收端则从应用层往上走。</p><p><img src="http://o6ljw8wcq.bkt.clouddn.com/blog/TCP.jpg" alt="TCP/IP 通信传输流"></p><h2 id="Socket-的基本概念"><a href="#Socket-的基本概念" class="headerlink" title="Socket 的基本概念"></a>Socket 的基本概念</h2><p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。它把复杂的 TCP/IP 协议族隐藏在 Socket API 后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。也就是说， TCP/IP 提供给程序员做网络开发所用的接口就是 Socket 编程接口。</p><h3 id="利用-Socket-建立网络连接的步骤与基本操作"><a href="#利用-Socket-建立网络连接的步骤与基本操作" class="headerlink" title="利用 Socket 建立网络连接的步骤与基本操作"></a>利用 Socket 建立网络连接的步骤与基本操作</h3><p>利用 Socket 建立网络至少需要一对 Socket，其中一个运行于客户端，称为 ClientSocket ,运行于服务端的称为 ServerSocket。</p><p>套接字（Socket 的译名）之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。<br>　　1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。<br>　　2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。<br>　　为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br>　　3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。</p><p><img src="http://upload-images.jianshu.io/upload_images/2392820-d6b764fefd4de351.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Socket 的基本操作（图是盗的）"></p><h2 id="常用的三种-Socket-类型"><a href="#常用的三种-Socket-类型" class="headerlink" title="常用的三种 Socket 类型"></a>常用的三种 Socket 类型</h2><ul><li>流式 Socket（SOCK_STREAM）:流式是一种面向连接的 Socket，针对于面向连接的 TCP服务应用</li><li>数据报式 Socket（SOCK_DGRAM）:数据报式 Socket 是一种无连接的 Socket，对应于无连接的UDP 服务应用。</li><li>Unix 域 Socket （Unix Domain Socket）：Socket API原本是为网络通讯设计的，但后来在Socket 的框架上发展出一种IPC机制，就是Unix  Domain Socket，用于同一台主机的进程间通讯。虽然网络socket也可用于同一台主机的进程间通讯（通过 loopback 地址127.0.0.1），但是Unix Domain Socket更有效率，不需要经过网络协议栈，只是将应用层数据从一个进程拷贝到另一个进程。</li></ul><h2 id="Socket-实践——在-Nodejs-中使用-TCP-套接字编程"><a href="#Socket-实践——在-Nodejs-中使用-TCP-套接字编程" class="headerlink" title="Socket 实践——在 Nodejs 中使用 TCP 套接字编程"></a>Socket 实践——在 Nodejs 中使用 TCP 套接字编程</h2><p>服务端代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">"net"</span>);</span><br><span class="line"><span class="keyword">const</span> host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = net</span><br><span class="line">  .createServer(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`客户端<span class="subst">$&#123;c.remoteAddress&#125;</span>:<span class="subst">$&#123;c.remotePort&#125;</span>已连接`</span>);</span><br><span class="line">     <span class="comment">// "data" 事件处理函数</span></span><br><span class="line">    c.on(<span class="string">"data"</span>, data =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`来自客户端<span class="subst">$&#123;c.remoteAddress&#125;</span>:<span class="subst">$&#123;c.remotePort&#125;</span>的数据:<span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">      c.write(<span class="string">`已收到你的数据`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    c.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`客户端<span class="subst">$&#123;c.remoteAddress&#125;</span>:<span class="subst">$&#123;c.remotePort&#125;</span>断开连接`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(port, host);</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.js</span></span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">"net"</span>);</span><br><span class="line"><span class="keyword">const</span> host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> net.Socket();</span><br><span class="line"></span><br><span class="line">client.connect(port, host, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`连接至<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">  <span class="comment">// 向服务端发送数据</span></span><br><span class="line">  client.write(<span class="string">`Hello!World!`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// "data" 事件处理函数</span></span><br><span class="line">  client.on(<span class="string">"data"</span>, data =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`服务器发回: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">    client.destroy();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`断开连接`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>《图解 HTTP》</li><li><a href="https://www.zhihu.com/question/39541968/answer/81841947" target="_blank" rel="noopener">TCP/IP、HTTP、Socket 的区别</a></li><li><a href="https://nodejs.org/api/net.html" target="_blank" rel="noopener">Net | Node.js Doc</a></li><li><a href="https://www.hacksparrow.com/tcp-socket-programming-in-node-js.html" target="_blank" rel="noopener">TCP Socket Programming in Node.js</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络基础-TCP-IP&quot;&gt;&lt;a href=&quot;#网络基础-TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;网络基础 TCP/IP&quot;&gt;&lt;/a&gt;网络基础 TCP/IP&lt;/h2&gt;&lt;p&gt;在讨论 Socket 之前，我们得先追本溯源，看看 TCP/IP 是
      
    
    </summary>
    
      <category term="Tech" scheme="http://zhoushidong.cc/categories/Tech/"/>
    
    
      <category term="socket" scheme="http://zhoushidong.cc/tags/socket/"/>
    
      <category term="TCP" scheme="http://zhoushidong.cc/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>The pits I met when I use MongoDB</title>
    <link href="http://zhoushidong.cc/2017/04/23/The-pits-I-met-when-I-use-MongoDB/"/>
    <id>http://zhoushidong.cc/2017/04/23/The-pits-I-met-when-I-use-MongoDB/</id>
    <published>2017-04-22T16:11:42.000Z</published>
    <updated>2017-04-23T09:05:50.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Oh-my-bindIp"><a href="#1-Oh-my-bindIp" class="headerlink" title="1. Oh my bindIp"></a>1. Oh my bindIp</h2><p>在服务器上装了 MongDB 后，想在本地环境用可视化工具来管理 MongoDB ，可是死活连不上。后来发现在配置文件<code>/etc/mongod.conf</code>中，其默认的 bindIp 为 <code>127.0.0.1</code>，也就是说数据库只限内网访问。将其改为<code>0.0.0.0</code>或其他指定环境即可。若想指定多个 ip ，每个 ip 之间用逗号分隔。</p><h3 id="127-0-0-1-、-localhost-和-0-0-0-0"><a href="#127-0-0-1-、-localhost-和-0-0-0-0" class="headerlink" title="127.0.0.1 、 localhost 和  0.0.0.0"></a>127.0.0.1 、 localhost 和  0.0.0.0</h3><ul><li><p>127.0.0.1 是一个环回地址（Loopback address）。地址块 127.0.0.1/8 被保留作环回通信用。此范围中的地址绝不应出现在主机之外，发送至此地址的报文被作为同一虚拟网络设备上的入站报文（<a href="https://en.wikipedia.org/wiki/Loopback" target="_blank" rel="noopener">Loopback</a>），主要用于检查 TCP/IP 协议栈是否正确运行和本机对本机的链接。所以，在外部网络环境是访问不到 127.0.0.1 的。</p></li><li><p>localhost 是一个域名，它其实可以被配置为任意地址。平常我们认为 localhost = 127.0.0.0.1，是因为操作系统中的 hosts 文件定义了localhost = 127.0.0.1，在操作系统支持 ipv6 后，它同时还指向ipv6 的地址 [::1]。</p></li><li><p>在服务器的上下文中，0.0.0.0 代表的意思是“主机上所有本地的 IPv4 地址”，如果一个主机有两个 ip 地址，192.168.1.1 和 10.1.2.1，并且该主机上的一个服务监听的地址是0.0.0.0,那么通过两个 ip 地址都能够访问该服务。 </p><p>在路由中，0.0.0.0表示的是默认路由，即当路由表中没有找到完全匹配的路由的时候所对应的路由。</p></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference :"></a>Reference :</h3><ol><li><a href="https://en.wikipedia.org/w/index.php?title=0.0.0.0&amp;redirect=no" target="_blank" rel="noopener">0.0.0.0 | wikipedia</a></li><li><a href="https://serverfault.com/questions/78048/whats-the-difference-between-ip-address-0-0-0-0-and-127-0-0-1" target="_blank" rel="noopener">What’s the difference between ip address 0.0.0.0 and 127.0.0.1?</a></li><li><a href="https://www.zhihu.com/question/23940717/answer/26230963" target="_blank" rel="noopener">localhost、127.0.0.1 和 本机IP 三者的区别?</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Oh-my-bindIp&quot;&gt;&lt;a href=&quot;#1-Oh-my-bindIp&quot; class=&quot;headerlink&quot; title=&quot;1. Oh my bindIp&quot;&gt;&lt;/a&gt;1. Oh my bindIp&lt;/h2&gt;&lt;p&gt;在服务器上装了 MongDB 后，想在本
      
    
    </summary>
    
      <category term="Tech" scheme="http://zhoushidong.cc/categories/Tech/"/>
    
    
      <category term="MongoDB" scheme="http://zhoushidong.cc/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Log:2017-4-11</title>
    <link href="http://zhoushidong.cc/2017/04/12/Log-2017-4-11/"/>
    <id>http://zhoushidong.cc/2017/04/12/Log-2017-4-11/</id>
    <published>2017-04-12T14:46:01.000Z</published>
    <updated>2017-04-12T14:58:59.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Read-📖"><a href="#Read-📖" class="headerlink" title="Read 📖"></a>Read 📖</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta" target="_blank" rel="noopener">meta | MDN</a></li><li><a href="https://html.spec.whatwg.org/multipage/semantics.html#the-meta-element" target="_blank" rel="noopener">The meta element | whatwg</a></li><li><a href="https://www.w3.org/TR/2016/REC-html51-20161101/document-metadata.html#the-meta-element" target="_blank" rel="noopener">The meta element | w3.org</a></li></ul><h2 id="Practice-⚽"><a href="#Practice-⚽" class="headerlink" title="Practice ⚽"></a>Practice ⚽</h2><p>None.</p><h2 id="Thought-💭"><a href="#Thought-💭" class="headerlink" title="Thought 💭"></a>Thought 💭</h2><p>Have known more about <code>&lt;meta&gt;</code>. Gotta learn about <code>viewport</code> in a few days.</p><p>And I realized that official standards or documents are the best learning materials.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Read-📖&quot;&gt;&lt;a href=&quot;#Read-📖&quot; class=&quot;headerlink&quot; title=&quot;Read 📖&quot;&gt;&lt;/a&gt;Read 📖&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN
      
    
    </summary>
    
      <category term="Log" scheme="http://zhoushidong.cc/categories/Log/"/>
    
    
  </entry>
  
  <entry>
    <title>最熟悉的陌生人——&lt;meta&gt; 标签</title>
    <link href="http://zhoushidong.cc/2017/04/11/%E8%B0%88%E8%B0%88-meta-%E6%A0%87%E7%AD%BE/"/>
    <id>http://zhoushidong.cc/2017/04/11/谈谈-meta-标签/</id>
    <published>2017-04-11T11:50:31.000Z</published>
    <updated>2017-04-11T15:42:14.229Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o6ljw8wcq.bkt.clouddn.com/blog/4-11/TIM%E6%88%AA%E5%9B%BE20170411195731.png" alt="meta 标签"></p><h2 id="元数据-Metadata"><a href="#元数据-Metadata" class="headerlink" title="元数据 Metadata"></a>元数据 Metadata</h2><p>在<code>html</code>中，每个<code>DOM</code>元素都有其内容模型（Content model）：</p><blockquote><p>An <a href="https://www.w3.org/TR/html51/infrastructure.html#html-element" target="_blank" rel="noopener">HTML element</a> must have contents that match the requirements described in the element’s content model.</p></blockquote><p>而所谓 <code>Content</code> 正是指该<code>DOM</code>元素的子项。根据 <code>Content</code> ，又可将<code>DOM</code>元素分为好几个类别，其中，<code>Metadata content</code>一类包含以下元素：  <code>&lt;base&gt;</code> <code>&lt;link&gt;</code> <code>&lt;meta&gt;</code> <code>&lt;noscript&gt;</code> <code>&lt;script&gt;</code> <code>&lt;style&gt;</code> <code>&lt;template&gt;</code> <code>&lt;title&gt;</code></p><blockquote><p>Metadata content is content that sets up the presentation or behavior of the rest of the content, or that sets up the relationship of the document with other documents, or that conveys other “out of band” information.</p></blockquote><p>而<code>meta</code>元素用来表示那些不能由其他<code>Metadata content</code>类元素表示的元数据（Metadata），如页面的说明，关键字，最后修改日期等。移动互联网出现之后，其<code>name</code>属性中的<code>viewport</code>被广泛应用于移动 web。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>meta标签共有四个属性：</p><ol><li>charset</li><li>content</li><li>http-equiv</li><li>name（全局属性，在<code>&lt;meta&gt;</code>中有特殊含义）</li><li>itemprop（全局属性）</li></ol><h3 id="1-charset"><a href="#1-charset" class="headerlink" title="1.charset"></a>1.charset</h3><blockquote><p>The <code>charset</code> attribute specifies the character encoding used by the document. This is a <a href="https://www.w3.org/TR/html51/document-metadata.html#character-encoding-declaration" target="_blank" rel="noopener">character encoding declaration</a>.</p></blockquote><p>注意：每个<code>html</code>文档不能有多个具有<code>charset</code>属性的<code>meta</code>元素</p><p>关于编码详情：<a href="https://www.w3.org/TR/html51/document-metadata.html#specifying-the-documents-character-encoding" target="_blank" rel="noopener">https://www.w3.org/TR/html51/document-metadata.html#specifying-the-documents-character-encoding</a></p><h3 id="2-content"><a href="#2-content" class="headerlink" title="2.content"></a>2.content</h3><p>这个属性为 <code>http-equiv</code> 或 <code>name</code> 属性提供了与其相关的值的定义，其值取决于具体的上下文。</p><h3 id="3-http-equiv"><a href="#3-http-equiv" class="headerlink" title="3.http-equiv"></a>3.http-equiv</h3><p><code>http-equiv</code> 属性是一个可枚举属性。下表是属性可选关键字及这些关键字所映射的内容。</p><table><thead><tr><th>关键字</th><th>所映射的内容</th><th>备注</th></tr></thead><tbody><tr><td><code>content-language</code></td><td><a href="https://www.w3.org/TR/html51/document-metadata.html#statedef-http-equiv-content-language" target="_blank" rel="noopener">Content Language</a></td><td>已过时。 使用<code>&lt;html&gt;</code>元素上全局的 <strong>lang</strong> 属性来替代它。</td></tr><tr><td><code>content-type</code></td><td><a href="https://www.w3.org/TR/html51/document-metadata.html#statedef-http-equiv-content-type" target="_blank" rel="noopener">Encoding declaration</a></td><td>已过时。推荐使用<code>&lt;meta charset=&quot;&quot;&gt;</code>。不能和含有<code>charset</code>属性的<code>&lt;meta&gt;</code>标签同时使用。</td></tr><tr><td><code>default-style</code></td><td><a href="https://www.w3.org/TR/html51/document-metadata.html#statedef-http-equiv-default-style" target="_blank" rel="noopener">Default style</a></td><td></td></tr><tr><td><code>refresh</code></td><td><a href="https://www.w3.org/TR/html51/document-metadata.html#statedef-http-equiv-refresh" target="_blank" rel="noopener">Refresh</a></td><td></td></tr><tr><td><code>set-cookie</code></td><td><a href="https://www.w3.org/TR/html51/document-metadata.html#statedef-http-equiv-set-cookie" target="_blank" rel="noopener">Cookie setter</a></td><td>已过时。 使用HTTP header set-cookie 来替代它。</td></tr><tr><td><code>content-security-policy</code></td><td><a href="https://html.spec.whatwg.org/multipage/semantics.html#attr-meta-http-equiv-content-security-policy" target="_blank" rel="noopener">Content security policy</a></td><td></td></tr><tr><td><code>x-ua-compatible</code></td><td><a href="https://html.spec.whatwg.org/multipage/semantics.html#attr-meta-http-equiv-x-ua-compatible" target="_blank" rel="noopener">X-UA-Compatible</a></td></tr></tbody></table><ol><li><p><code>default-style</code></p><p>用于指定首选css。</p><blockquote><h2 id="Descriptions-for-attributes-specific-to-this-element"><a href="#Descriptions-for-attributes-specific-to-this-element" class="headerlink" title="Descriptions for attributes specific to this element"></a>Descriptions for attributes specific to this element</h2><ul><li><p><a href="https://www.w3.org/TR/2010/WD-html-markup-20100624/meta.http-equiv.default-style.html#meta.http-equiv.attrs.http-equiv.default-style" target="_blank" rel="noopener">http-equiv</a> = “default-style”</p><p>Indicates that the <a href="https://www.w3.org/TR/2010/WD-html-markup-20100624/meta.html#meta" target="_blank" rel="noopener">meta</a> element is a pragma directive that specifies the document’s preferred stylesheet.</p></li><li><p><a href="https://www.w3.org/TR/2010/WD-html-markup-20100624/meta.http-equiv.default-style.html#meta.http-equiv.attrs.content.default-style" target="_blank" rel="noopener">content</a> = <a href="https://www.w3.org/TR/2010/WD-html-markup-20100624/datatypes.html#common.data.default-style" target="_blank" rel="noopener">default-style name</a></p><p>Specifies the name of the document’s preferred stylesheet. The name must meet either of the following sets of constraints:</p><ul><li>The name must match the value of the <a href="https://www.w3.org/TR/2010/WD-html-markup-20100624/common-attributes.html#common.attrs.title" target="_blank" rel="noopener">title</a> attribute on a <a href="https://www.w3.org/TR/2010/WD-html-markup-20100624/link.html#link" target="_blank" rel="noopener">link</a> element in the same document, and that <a href="https://www.w3.org/TR/2010/WD-html-markup-20100624/link.html#link" target="_blank" rel="noopener">link</a> element must have an <a href="https://www.w3.org/TR/2010/WD-html-markup-20100624/link.html#link.attrs.href" target="_blank" rel="noopener">href</a> attribute that references the location of a CSS stylesheet.</li><li>The name must match the value of the <a href="https://www.w3.org/TR/2010/WD-html-markup-20100624/common-attributes.html#common.attrs.title" target="_blank" rel="noopener">title</a> attribute on a <a href="https://www.w3.org/TR/2010/WD-html-markup-20100624/style.html#style" target="_blank" rel="noopener">style</a> element in the same document, and the contents of that element must be a CSS stylesheet.</li></ul></li></ul></blockquote></li><li><p><code>refresh</code></p><p>每隔一段时间自动刷新并指向某页面，以下是使用举例</p><ol><li><p>新闻网站首页可能会在页面的头元素中包含以下标记，以确保页面每五分钟自动从服务器重新加载：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Refresh"</span> <span class="attr">content</span>=<span class="string">"300"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>可以将一系列页面用作自动幻灯片放映：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Refresh"</span> <span class="attr">content</span>=<span class="string">"20; URL=page4.html"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p><code>content-security-policy</code></p><p>通常防止站点脚本攻击（XSS）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"script-src 'self'; object-src 'none'"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>x-ua-compatible</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>/&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 指定IE使用最新版本渲染当前页面</span></span><br><span class="line"><span class="comment"> Note, the W3C validator will flag chrome=1 as an error.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="4-name"><a href="#4-name" class="headerlink" title="4.name"></a>4.name</h3><ol><li><p>application-name</p><p>设置 Web App 名称。可通过使用<code>lang</code>属性设置不同语言版本的名称。free-form string。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"application-name"</span> <span class="attr">content</span>=<span class="string">"zhizhi"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>author</p><p>标注网页作者。free-form string。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"zsd,clarkzsd@gmail.com"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>description</p><p>页面介绍。措辞应当合适，因为会在搜索引擎中显示。free-form string。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"betahouse工作室博客"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>keywords</p><p>页面关键字。set of comma-separated tokens。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"british,typeface,font,fonts,highway,highways"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>referrer</p><p>指定 referrer 策略</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"referrer"</span> <span class="attr">content</span>=<span class="string">"no-referrer|no-referrer-when-downgrade|origin|origin-when-crossorigin|unsafe-url"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于 referrer 策略: <a href="https://w3c.github.io/webappsec-referrer-policy/#referrer-policy" target="_blank" rel="noopener">https://w3c.github.io/webappsec-referrer-policy/#referrer-policy</a></p></li><li><p>theme-color</p><p>HTML 规范定义：</p><blockquote><p>The value must be a string that matches the CSS <a href="https://drafts.csswg.org/css-color/#typedef-color" target="_blank" rel="noopener">color</a> production, defining a suggested color that user agents should use to customize the display of the page or of the surrounding user interface. For example, a browser might color the page’s title bar with the specified value, or use it as a color highlight in a tab bar or task switcher.</p></blockquote><p>不过现在只有 Android 上面的 Chrome 支持 theme-color。</p><p><a href="https://developers.google.com/web/updates/2014/11/Support-for-theme-color-in-Chrome-39-for-Android" target="_blank" rel="noopener">Support for theme-color in Chrome 39 for Android</a></p><p><img src="https://developers.google.com/web/updates/images/2014/11/theme-color-ss.png" alt="theme-color in chrome"></p><p>注意：<code>name</code>为<code>theme-color</code>的<code>meta</code>元素只能出现一次。</p></li><li><p>generator</p><blockquote><p>The value must be a free-form string that identifies one of the software packages used to generate the document. This value must not be used on pages whose markup is not generated by software, e.g. pages whose markup was written by a user in a text editor.</p></blockquote><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">Here is what a tool called "Frontweaver" could include in its output, in the page's head element, to identify itself as the tool used to generate the page:</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">generator</span> <span class="attr">content</span>=<span class="string">"Frontweaver 8.2"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在过去，某些网站编辑器（如 FrontPage）会在创建新的HTML文档或使用它们发布站点时自动插入生成器标签。这被认为是指“此页面是使用FrontPage创建的”。现在几乎不使用……</p></li><li><h5 id="Other-metadata-names"><a href="#Other-metadata-names" class="headerlink" title="Other metadata names"></a>Other metadata names</h5><p>任何人都可以创建并使用自己的扩展 metadata name。</p><p>详情：<a href="https://html.spec.whatwg.org/multipage/semantics.html#other-metadata-names" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/semantics.html#other-metadata-names</a></p></li><li><p>viewport</p><p>viewport 指的是 web 的可视区域。在不同的设备上，viewport 都不同。</p><p>meta viewport标签首先是由 Apple 在其 safari 浏览器中引入的，目的是解决移动设备的 viewport 问题。后来其他各大厂商纷纷也引入了对 viewport 的支持。</p><p>这个特性虽然被广泛使用，但仍然未被标准化。（在 w3c 规范中翻了好久没翻出来。。。）</p></li></ol><table><thead><tr><th>Value</th><th>可能值</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>一个正整数或者字符串 <code>device-width</code></td><td>defines the width, in pixels, of the viewport</td></tr><tr><td>height</td><td>一个正整数或者字符串 <code>device-height</code></td><td>defines the height, in pixels, of the viewport</td></tr><tr><td>initial-scale</td><td><code>一个0.0</code> 到<code>10.0之间的正数</code></td><td>defines the ratio between the device width (device-width in portrait mode or device-height in landscape mode) and the viewport size.</td></tr><tr><td>maximum-scale</td><td><code>一个0.0</code> 到<code>10.0之间的正数</code></td><td>defines the maximum value of the zoom; it must be greater or equal to the <code>minimum-scale</code> or the behavior is indeterminate.</td></tr><tr><td>minimum-scale</td><td><code>一个0.0</code> 到<code>10.0之间的正数</code></td><td>defines the minimum value of the zoom; it must be smaller or equal to the maximum-scale or the behavior is indeterminate.</td></tr><tr><td><code>user-scalable</code></td><td>一个布尔值（yes 或者no）</td><td>If set to <code>no</code>, the user is not able to zoom in the webpage. Default value is yes.</td></tr></tbody></table><p>​    <a href="https://www.w3schools.com/css/css_rwd_viewport.asp" target="_blank" rel="noopener">Learn more about viewport</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta" target="_blank" rel="noopener">meta | MDN</a></li><li><a href="https://html.spec.whatwg.org/multipage/semantics.html#the-meta-element" target="_blank" rel="noopener">The meta element | whatwg</a></li><li><a href="https://www.w3.org/TR/2016/REC-html51-20161101/document-metadata.html#the-meta-element" target="_blank" rel="noopener">The meta element | w3.org</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://o6ljw8wcq.bkt.clouddn.com/blog/4-11/TIM%E6%88%AA%E5%9B%BE20170411195731.png&quot; alt=&quot;meta 标签&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;元数据-Metadata&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Tech" scheme="http://zhoushidong.cc/categories/Tech/"/>
    
    
      <category term="HTML" scheme="http://zhoushidong.cc/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Log:2017-4-10</title>
    <link href="http://zhoushidong.cc/2017/04/10/Log-2017-4-10/"/>
    <id>http://zhoushidong.cc/2017/04/10/Log-2017-4-10/</id>
    <published>2017-04-10T15:03:40.000Z</published>
    <updated>2017-04-12T14:47:03.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Read-📖"><a href="#Read-📖" class="headerlink" title="Read 📖"></a>Read 📖</h2><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta" target="_blank" rel="noopener">meta | MDN</a></li><li><a href="https://nodesource.com/blog/configuring-your-npmrc-for-an-optimal-node-js-environment" target="_blank" rel="noopener">Configuring Your .npmrc for an Optimal Node.js Environment</a></li></ol><h2 id="Practice-⚽"><a href="#Practice-⚽" class="headerlink" title="Practice ⚽"></a>Practice ⚽</h2><p>None.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Read-📖&quot;&gt;&lt;a href=&quot;#Read-📖&quot; class=&quot;headerlink&quot; title=&quot;Read 📖&quot;&gt;&lt;/a&gt;Read 📖&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US
      
    
    </summary>
    
      <category term="Log" scheme="http://zhoushidong.cc/categories/Log/"/>
    
    
  </entry>
  
  <entry>
    <title>Log:2017-4-9</title>
    <link href="http://zhoushidong.cc/2017/04/09/Log-2017-4-9/"/>
    <id>http://zhoushidong.cc/2017/04/09/Log-2017-4-9/</id>
    <published>2017-04-09T10:08:55.000Z</published>
    <updated>2017-04-10T10:54:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Read-📖"><a href="#Read-📖" class="headerlink" title="Read 📖"></a>Read 📖</h2><p>None.</p><h2 id="Practice-⚽"><a href="#Practice-⚽" class="headerlink" title="Practice ⚽"></a>Practice ⚽</h2><ol><li><a href="https://github.com/clarkzsd/IFE-2017/tree/master/html%26css/task10" target="_blank" rel="noopener">IFE Flexbox practice</a></li></ol><h2 id="Thought-💭"><a href="#Thought-💭" class="headerlink" title="Thought 💭"></a>Thought 💭</h2><p>Today, we met the new guys. Young and passionate, they know more about tech stuff than me in the past when I participate the recruitment of β-house. Wow!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Read-📖&quot;&gt;&lt;a href=&quot;#Read-📖&quot; class=&quot;headerlink&quot; title=&quot;Read 📖&quot;&gt;&lt;/a&gt;Read 📖&lt;/h2&gt;&lt;p&gt;None.&lt;/p&gt;
&lt;h2 id=&quot;Practice-⚽&quot;&gt;&lt;a href=&quot;#Practice-⚽
      
    
    </summary>
    
      <category term="Log" scheme="http://zhoushidong.cc/categories/Log/"/>
    
    
  </entry>
  
  <entry>
    <title>Log:2017-4-8</title>
    <link href="http://zhoushidong.cc/2017/04/08/Log-2017-4-8/"/>
    <id>http://zhoushidong.cc/2017/04/08/Log-2017-4-8/</id>
    <published>2017-04-08T15:31:54.000Z</published>
    <updated>2017-04-08T15:54:58.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Read-📖"><a href="#Read-📖" class="headerlink" title="Read 📖"></a>Read 📖</h2><p>None.</p><h2 id="Practice-⚽"><a href="#Practice-⚽" class="headerlink" title="Practice ⚽"></a>Practice ⚽</h2><p>None.</p><h2 id="What-Happened-Today-❔"><a href="#What-Happened-Today-❔" class="headerlink" title="What Happened Today ❔"></a>What Happened Today ❔</h2><p>今天关于工作室的事情谈了很多。一是关于招新的事，二是关于工作室以后的发展。</p><p>从宣传开始算的话，我们的招新开始时间比去年晚了很多，然后从宣传开始到正式电话面试中间又由于各种事情拖了很长时间。由于校区的原因，招新主要由我们大二的负责。总的来说，大二的我们应对招新还是有点吃力的，一切都匆匆忙忙的，总感觉自己经验不足。面对明天的招新见面会也感觉没有准备充分。</p><p>关于工作室以后的发展，真的十分感谢工作室的前辈们为我们打下的基础。在团队建设方面，我们已经有自己的官网、博客和招新网站，现在又有了基于 Websocket 的聊天室和基于 flarum 的校园论坛（未推广上线）。前几天麻凯倩学姐又帮我们申请了 npm 的 group。在职的前辈们都十分关注工作室的发展。真的十分感谢。现在我们要做的事，就是在前辈们留下的基础上打造出属于 β-house 自己的面向校园的产品，这样工作室才能长远发展。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Read-📖&quot;&gt;&lt;a href=&quot;#Read-📖&quot; class=&quot;headerlink&quot; title=&quot;Read 📖&quot;&gt;&lt;/a&gt;Read 📖&lt;/h2&gt;&lt;p&gt;None.&lt;/p&gt;
&lt;h2 id=&quot;Practice-⚽&quot;&gt;&lt;a href=&quot;#Practice-⚽
      
    
    </summary>
    
      <category term="Log" scheme="http://zhoushidong.cc/categories/Log/"/>
    
    
  </entry>
  
  <entry>
    <title>Log:2017-4-7</title>
    <link href="http://zhoushidong.cc/2017/04/07/Log-2017-4-7/"/>
    <id>http://zhoushidong.cc/2017/04/07/Log-2017-4-7/</id>
    <published>2017-04-07T02:49:10.000Z</published>
    <updated>2017-04-07T15:40:40.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Read-📖"><a href="#Read-📖" class="headerlink" title="Read 📖"></a>Read 📖</h2><h3 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h3><ol><li><a href="https://segmentfault.com/a/1190000002910324" target="_blank" rel="noopener">Flexbox 详解</a></li><li><a href="https://www.w3cplus.com/css3/a-visual-guide-to-css3-flexbox-properties.html" target="_blank" rel="noopener">a-visual-guide-to-css3-flexbox-properties</a></li></ol><h2 id="Practice-⚽"><a href="#Practice-⚽" class="headerlink" title="Practice ⚽"></a>Practice ⚽</h2><ol><li><a href="https://github.com/clarkzsd/IFE-2017/tree/master/html%26css/task4" target="_blank" rel="noopener">Centering in CSS</a></li><li>Meet Flexbox(unfinished)</li></ol><h2 id="Thought-💭"><a href="#Thought-💭" class="headerlink" title="Thought 💭"></a>Thought 💭</h2><p>The world has become flat. So how can you stand out in comparison with the others?</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Read-📖&quot;&gt;&lt;a href=&quot;#Read-📖&quot; class=&quot;headerlink&quot; title=&quot;Read 📖&quot;&gt;&lt;/a&gt;Read 📖&lt;/h2&gt;&lt;h3 id=&quot;Flexbox&quot;&gt;&lt;a href=&quot;#Flexbox&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Log" scheme="http://zhoushidong.cc/categories/Log/"/>
    
    
      <category term="css" scheme="http://zhoushidong.cc/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Log:2017-4-6</title>
    <link href="http://zhoushidong.cc/2017/04/06/Log-2017-4-6/"/>
    <id>http://zhoushidong.cc/2017/04/06/Log-2017-4-6/</id>
    <published>2017-04-06T14:40:43.000Z</published>
    <updated>2017-04-07T00:58:44.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Read-📖"><a href="#Read-📖" class="headerlink" title="Read 📖"></a>Read 📖</h2><h3 id="Centering-in-CSS"><a href="#Centering-in-CSS" class="headerlink" title="Centering in CSS"></a>Centering in CSS</h3><ol><li><a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="noopener">Centering in CSS: A Complete Guide</a></li></ol><h3 id="Positioning-in-CSS"><a href="#Positioning-in-CSS" class="headerlink" title="Positioning in CSS"></a>Positioning in CSS</h3><ol><li><a href="http://www.w3cplus.com/css/advanced-html-css-lesson2-detailed-css-positioning.html" target="_blank" rel="noopener">HTML和CSS高级指南之二——定位详解</a></li></ol><h2 id="Practice-⚽"><a href="#Practice-⚽" class="headerlink" title="Practice ⚽"></a>Practice ⚽</h2><p><a href="https://github.com/clarkzsd/IFE-2017/tree/master/html%26css/task4" target="_blank" rel="noopener">Centering in CSS</a>(unfinished)</p><h2 id="Thought-💭"><a href="#Thought-💭" class="headerlink" title="Thought 💭"></a>Thought 💭</h2><p>This world doesn’t deserve Superman. </p><p>Men are not good enough.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Read-📖&quot;&gt;&lt;a href=&quot;#Read-📖&quot; class=&quot;headerlink&quot; title=&quot;Read 📖&quot;&gt;&lt;/a&gt;Read 📖&lt;/h2&gt;&lt;h3 id=&quot;Centering-in-CSS&quot;&gt;&lt;a href=&quot;#Centering-in-CSS&quot;
      
    
    </summary>
    
      <category term="Log" scheme="http://zhoushidong.cc/categories/Log/"/>
    
    
      <category term="css" scheme="http://zhoushidong.cc/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Log:2017-4-5</title>
    <link href="http://zhoushidong.cc/2017/04/05/Log-2017-4-5/"/>
    <id>http://zhoushidong.cc/2017/04/05/Log-2017-4-5/</id>
    <published>2017-04-05T12:51:10.000Z</published>
    <updated>2017-04-05T13:59:22.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Read-📖"><a href="#Read-📖" class="headerlink" title="Read 📖"></a>Read 📖</h2><h3 id="CSS-Layout"><a href="#CSS-Layout" class="headerlink" title="CSS Layout"></a>CSS Layout</h3><ol><li><a href="http://zh.learnlayout.com/" target="_blank" rel="noopener">Learn CSS Layout</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position" target="_blank" rel="noopener">MDN：position</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener">MDN：float</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries" target="_blank" rel="noopener">MDN：media queries</a></li></ol><h3 id="CSS-Clearfix"><a href="#CSS-Clearfix" class="headerlink" title="CSS Clearfix"></a>CSS Clearfix</h3><ol><li><a href="http://www.w3cplus.com/css/advanced-html-css-lesson2-detailed-css-positioning.html" target="_blank" rel="noopener">advanced-html-css-lesson2-detailed-css-positioning</a></li></ol><h2 id="Practice-⚽"><a href="#Practice-⚽" class="headerlink" title="Practice ⚽"></a>Practice ⚽</h2><ol><li><a href="https://github.com/clarkzsd/IFE-2017/tree/master/html%26css/task3" target="_blank" rel="noopener">Three Column Layout</a></li></ol><h2 id="Idea-💡"><a href="#Idea-💡" class="headerlink" title="Idea 💡"></a>Idea 💡</h2><p>From this day onwards, note down what I read, what I program and what I think.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Read-📖&quot;&gt;&lt;a href=&quot;#Read-📖&quot; class=&quot;headerlink&quot; title=&quot;Read 📖&quot;&gt;&lt;/a&gt;Read 📖&lt;/h2&gt;&lt;h3 id=&quot;CSS-Layout&quot;&gt;&lt;a href=&quot;#CSS-Layout&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Log" scheme="http://zhoushidong.cc/categories/Log/"/>
    
    
      <category term="css" scheme="http://zhoushidong.cc/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>无题 2017年3月19日</title>
    <link href="http://zhoushidong.cc/2017/03/19/%E6%97%A0%E9%A2%98-2017%E5%B9%B43%E6%9C%8819%E6%97%A5/"/>
    <id>http://zhoushidong.cc/2017/03/19/无题-2017年3月19日/</id>
    <published>2017-03-19T15:15:13.000Z</published>
    <updated>2017-03-19T15:20:07.895Z</updated>
    
    <content type="html"><![CDATA[<p>藏在笼子中的灰暗时光啊，它是多么需要一点别样的色彩。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;藏在笼子中的灰暗时光啊，它是多么需要一点别样的色彩。&lt;/p&gt;

      
    
    </summary>
    
      <category term="言语" scheme="http://zhoushidong.cc/categories/%E8%A8%80%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义checkbox、radio样式</title>
    <link href="http://zhoushidong.cc/2017/02/28/%E8%87%AA%E5%AE%9A%E4%B9%89checkbox%E3%80%81radio%E6%A0%B7%E5%BC%8F/"/>
    <id>http://zhoushidong.cc/2017/02/28/自定义checkbox、radio样式/</id>
    <published>2017-02-28T07:35:49.000Z</published>
    <updated>2017-03-12T04:42:25.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p><a href="http://ife.baidu.com/course/detail/id/23" target="_blank" rel="noopener">自定义checkbox、radio样式</a></p><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="一-伪元素与伪类"><a href="#一-伪元素与伪类" class="headerlink" title="一.伪元素与伪类"></a>一.伪元素与伪类</h2><p>CSS伪类是添加到选择器的关键字，指定要选择的元素的特殊状态。例如，:hover 将在用户悬停在选择器指定的元素上时应用样式。</p><p>而伪元素并不指定所选择元素的特殊状态，它指定的是所选择元素的某些部分，相当于是指定一个虚拟的DOM元素的样式，例如<code>::first-line</code>指定该元素的第一行的样式。</p><p><img src="https://ooo.0o0.ooo/2017/02/28/58b52dea12c11.png" alt="所有的伪元素"></p><p>为了更好的区分伪元素和伪类，CSS3中伪元素使用两个冒号(::)表示，伪类使用一个冒号(:)。</p><h2 id="二-雪碧图"><a href="#二-雪碧图" class="headerlink" title="二.雪碧图"></a>二.雪碧图</h2><p>CSS雪碧图的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS <code>background</code>和<code>background-position</code>属性渲染。</p><h2 id="三-需求实现"><a href="#三-需求实现" class="headerlink" title="三.需求实现"></a>三.需求实现</h2><h2 id="伪元素实现"><a href="#伪元素实现" class="headerlink" title="伪元素实现"></a>伪元素实现</h2><ol><li>实现原理：隐藏原生<code>input</code>标签，给与其关联的<code>label</code>添加样式，实现自定义控件。</li><li>代码：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo1"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"radio1"</span> <span class="attr">type</span>=<span class="string">"radio"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"radio_label demo1_radio"</span> <span class="attr">for</span>=<span class="string">"radio1"</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"checkbox1"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"checkbox_label demo1_checkbox"</span> <span class="attr">for</span>=<span class="string">"checkbox1"</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">13px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.demo1</span> &gt; <span class="selector-tag">label</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid darkgray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.radio_label</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="radio"]</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.demo1_radio</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\25CF"</span>;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.demo1_checkbox</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\2714"</span>;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>坑：<ul><li><code>content</code>属性用于在<code>::before</code>和<code>::after</code>伪元素中插入内容，其内容都是匿名的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element" target="_blank" rel="noopener">可替换元素</a>。在这里为了实现控件的选中效果，使用的是16进制 unicode 编码（计算机中每个字符都对应一个 unicode 编码）。</li><li>在指定控件在被选中时的状态样式时，需要根据<code>input:checked</code>与<code>label</code>的相邻关系来对其应用样式，这时需要用到相邻同胞选择器<code>+</code>（用于定位同一个父元素之下某个元素之后的元素）。</li></ul></li></ol><h2 id="雪碧图实现"><a href="#雪碧图实现" class="headerlink" title="雪碧图实现"></a>雪碧图实现</h2><ol><li><p>实现原理：隐藏<code>input</code>，给<code>label</code>加背景图片。使用<code>background</code>和<code>background-position</code>属性分别渲染出所需要的图片。（所以你点的可能是个假控件）。</p></li><li><p>代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"radio2"</span> <span class="attr">type</span>=<span class="string">"radio"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"radio_label demo2_radio"</span> <span class="attr">for</span>=<span class="string">"radio2"</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"checkbox2"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"checkbox_label demo2_checkbox"</span> <span class="attr">for</span>=<span class="string">"checkbox2"</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo2</span> &gt; <span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(http://p1.bqimg.com/567571/99322cf8c3283e42.png) no-repeat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="radio"]</span> + <span class="selector-class">.demo2_radio</span> &#123;</span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">23px</span> -<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span> + <span class="selector-class">.demo2_checkbox</span> &#123;</span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">25px</span> -<span class="number">32px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="radio"]</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.demo2_radio</span> &#123;</span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">58px</span> -<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.demo2_checkbox</span> &#123;</span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">60px</span> -<span class="number">32px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>坑：找出精确的<code>background-position</code>需要借助 Photoshop……</p></li></ol><h2 id="优劣比较"><a href="#优劣比较" class="headerlink" title="优劣比较"></a>优劣比较</h2><ul><li>使用伪元素不产生http请求，性能较高。代码量较多。</li><li>使用雪碧图代码量较少。<code>background-position</code>的值需要十分精确，不然点击时会产生bug。但是，用雪碧图能更方便地实现自定义的元素样式。</li></ul>]]></content>
    
    <summary type="html">
    
      CSS伪类是添加到选择器的关键字，指定要选择的元素的特殊状态。例如，:hover 将在用户悬停在选择器指定的元素上时应用样式。
    
    </summary>
    
      <category term="Tech" scheme="http://zhoushidong.cc/categories/Tech/"/>
    
    
      <category term="css" scheme="http://zhoushidong.cc/tags/css/"/>
    
      <category term="ife" scheme="http://zhoushidong.cc/tags/ife/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 函数中的apply()、call()和bind()</title>
    <link href="http://zhoushidong.cc/2017/02/19/JavaScript-%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84apply-%E3%80%81call-%E5%92%8Cbind/"/>
    <id>http://zhoushidong.cc/2017/02/19/JavaScript-函数中的apply-、call-和bind/</id>
    <published>2017-02-19T09:15:21.000Z</published>
    <updated>2017-02-22T10:09:07.807Z</updated>
    
    <content type="html"><![CDATA[<p>第一次接触这三个方法时，我还没怎么写过 js，一直无法理解这三个方法的作用，MDN 上的资料也看不懂。现在回过头来继续啃这些知识点，顿时就有豁然开朗之感了。</p><h1 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h1><p>ECMAScript 中的函数是对象，因此函数也有属性和方法。每个函数包含两个属性：length 和 prototype。length 表示函数的参数个数：</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(num1,num2)</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(sum.<span class="built_in">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>而 prototype 所对应的就是该对象传说中的原型了。对于 ECMAScript 中的引用类型而言，prototype 保存着它们所有实例方法，对于函数来讲，其 prototype 中就包括 apply()、call() 和 bind()。</p><h1 id="apply-与-call"><a href="#apply-与-call" class="headerlink" title="apply() 与 call()"></a>apply() 与 call()</h1><p>这两个方法的用途都是在特定的作用域中调用函数。换句话说就是设置函数体中的 this 的值。</p><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p>apply() 接受两个参数，第一个是要设定的作用域，另一个是参数数组（arguments 对象亦可）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line"> <span class="comment">// or: return sum.apply(this,[num1,num2]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(callSum1(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>在此处是在全局作用域环境下调用的 callSum1,则 apply() 传入的 this 便是 window 对象（浏览器环境）。</p><p>另一个例子，扩充函数赖以运行的作用域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.word = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">word</span>:<span class="string">"World"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saySomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">saySomething(); <span class="comment">// Hello</span></span><br><span class="line">saySomething.apply(<span class="built_in">window</span>); <span class="comment">// Hello</span></span><br><span class="line">saySomething.apply(o); <span class="comment">// World</span></span><br></pre></td></tr></table></figure><p>在第三次调用 saySomething() 时，该函数的执行环境变了，this 指向了 o，所以打印出来的是 “World”。</p><p>使用 apply() 和 call() 来扩充函数赖以运行的作用域的好处是，对象不需要与方法有任何耦合关系，这样能大大增加代码的复用性。</p><h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><p>call() 与 apply() 大同小异，它的作用与 apply() 是相同的。只是传递给 call() 的参数必须逐个列举出来：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span><span class="params">(num1,num2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.call(<span class="keyword">this</span>,num1,num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h1><p>bind() 方法会新建一个函数的实例，这个函数实例的 this 值会被绑定到传给 bind() 函数的值。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span></span>() &#123;</span><br><span class="line">  console.log(<span class="built_in">this</span> === obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const <span class="keyword">new</span><span class="type">Test</span> = test.bind(obj);</span><br><span class="line">test(); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span><span class="type">Test</span>(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>newTest() 函数中的 this 始终指向 obj，无论在哪里调用，其输出结果始终是 true。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>JS 中 this 是动态指向的，而 bind() 便可以把 this 固定住。我们来看一个具体例子：</p><h3 id="click-事件处理"><a href="#click-事件处理" class="headerlink" title="click 事件处理"></a>click 事件处理</h3><p>定义一个日志对象来记录 click 的次数：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let logger = &#123;</span><br><span class="line">  <span class="built_in">count</span>:<span class="number">0</span>,</span><br><span class="line">  increment: <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">    this.<span class="built_in">count</span>++;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="built_in">count</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在点击事件的回调函数中调用该对象的 increment() 方法:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">document</span><span class="selector-class">.getElementById</span>(<span class="string">'btn'</span>)<span class="selector-class">.addEventListener</span>(<span class="string">'click'</span>, logger.increment);</span><br></pre></td></tr></table></figure><p>这里要注意的是，如果直接像上述代码这么写，那么 increment() 函数中的 this 指向的是 id 为 ‘btn’ 的 DOM 对象，而非 logger。这时就需要靠 bind() 出场了：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">document</span><span class="selector-class">.getElementById</span>(<span class="string">'btn'</span>)<span class="selector-class">.addEventListener</span>(<span class="string">'click'</span>, logger.increment.bind(logger));</span><br></pre></td></tr></table></figure><p>如果你用 ES6 写 React 的话，上述场景你一定不会陌生。在写事件函数时，我们经常需要 bind() 一下来保证 this 一直指向组件实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">handleClick(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而用 ES5 写时， 使用 React.createClass() 来建立组件时，React 会帮你自动绑定函数的 this。</p>]]></content>
    
    <summary type="html">
    
      第一次接触这三个方法时，我还没怎么写过 js，一直无法理解这三个方法的作用，MDN 上的资料也看不懂。现在回过头来继续啃这些知识点，顿时就有豁然开朗之感了。
    
    </summary>
    
      <category term="Tech" scheme="http://zhoushidong.cc/categories/Tech/"/>
    
    
      <category term="JavaScript" scheme="http://zhoushidong.cc/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于 JavaScript 作用域</title>
    <link href="http://zhoushidong.cc/2017/02/10/%E5%85%B3%E4%BA%8E-JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://zhoushidong.cc/2017/02/10/关于-JavaScript-作用域/</id>
    <published>2017-02-10T09:19:09.000Z</published>
    <updated>2017-02-22T10:07:22.563Z</updated>
    
    <content type="html"><![CDATA[<p>最近看《JavaScript 语言精粹》时看到这么一句话：</p><blockquote><p>不像许多其它语言，JavaScript 中的代码块不会创建新的作用域，因此变量应该被定义在函数的头部，而不是在代码块中。</p></blockquote><p>那么我们就先来看看其它语言 (Java) 的块级作用域是怎么样的</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> age = <span class="number">3</span>;</span><br><span class="line">      System.<span class="keyword">out</span>.println(age); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.<span class="keyword">out</span>.println(age); <span class="comment">// Error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，age 是 if 这个语句块中的定义的块级变量，其生存周期就是这个语句块，所以在语句块外部访问是无效的。</p><p>在 JS 中，对于作用域，又可以分为全局作用域和局部作用域。局部作用域又被称为函数作用域（Function Scope），所有的变量和函数只能在作用域内部使用。</p><p>JS 是不支持块级作用域的，在语句块内中定义的变量可以在语句块外访问：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么会出现这样的情况？</p><h2 id="提升（hoisting）"><a href="#提升（hoisting）" class="headerlink" title="提升（hoisting）"></a>提升（hoisting）</h2><p>之所以在语句块外能访问，是因为<code>var</code>关键字声明变量时，有一个变量提升的过程：</p><blockquote><p>Because variable declarations (and declarations in general) are processed before any code is executed, declaring a variable anywhere in the code is equivalent to declaring it at the top. This also means that a variable can appear to be used before it’s declared. This behavior is called “hoisting”, as it appears that the variable declaration is moved to the top of the function or global code.</p></blockquote><p>而在 demo1 中，函数 test 中 if 语句块里面的 age 变量发生了变量提升，上述代码等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    age = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一点需要注意：所谓的变量提升只是其定义上升，而变量的赋值是不会上升的。</p><p>所以在 JS 中，我们总在作用域的最开始声明变量，这样可以使其作用域变得更加清晰。</p><p>同样的，在 JS 中，定义一个 function 时也会发生提升：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hoisted(); <span class="comment">// logs "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoisted</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而函数表达式(Function Expressions)是不会提升的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">notHoisted(); <span class="comment">// TypeError: notHoisted is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> notHoisted = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="let-in-ES6"><a href="#let-in-ES6" class="headerlink" title="let in ES6"></a>let in ES6</h2><p>在ES6中，新增了<code>let</code>关键字，用<code>let</code>声明的变量是存在块级作用域的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">3</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// ReferenceError: age is not defined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们谈及 JS 的作用域时，肯定会想到闭包、作用域链等概念。而这些知识，且待我学习学习先……</p><p>参考：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting" target="_blank" rel="noopener">Hoisting - Glossary | MDN</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var" target="_blank" rel="noopener">var - JavaScript | MDN</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看《JavaScript 语言精粹》时看到这么一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不像许多其它语言，JavaScript 中的代码块不会创建新的作用域，因此变量应该被定义在函数的头部，而不是在代码块中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么我们就
      
    
    </summary>
    
      <category term="Tech" scheme="http://zhoushidong.cc/categories/Tech/"/>
    
    
      <category term="JavaScript" scheme="http://zhoushidong.cc/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>忙</title>
    <link href="http://zhoushidong.cc/2017/01/25/%E5%BF%99/"/>
    <id>http://zhoushidong.cc/2017/01/25/忙/</id>
    <published>2017-01-25T09:20:26.000Z</published>
    <updated>2017-02-22T10:07:33.818Z</updated>
    
    <content type="html"><![CDATA[<p>有人说，每年年度总结定下的未来计划都是去年年度总结中定下的，就这样一年复一年，自己的“一年计划”从未实现。</p><p>我也没有在 2016 年度总结给我自己定下什么计划或者什么小目标，只是给自己定个方向，比如说多写博文、多看书等，期望自己能够有意识的往这个方向去靠。计划往往是赶不上变化的。高三的时候，每逢月考时，一个同班妹子在晚自修下课时总是抱着好几本复习资料回寝室看，第二天我问她你昨晚看了几本，她说一本还没翻几页就睡着了……妹子明显就是不尊重事物的客观规律嘛。</p><h2 id="期末考试"><a href="#期末考试" class="headerlink" title="期末考试"></a>期末考试</h2><p>从元旦开始到现在，自己一直处于一种比较忙碌的状态。元旦一过，期末考试就不远了，总得“预习”一下要考试的科目吧。</p><p>一直以来，我对大学里面的考试都是持“能过就行”这种态度，几个学期下来，我更加坚定了自己的想法。为什么这么说呢？</p><ol><li>这些学科考试实在太水，这样的考试根本就不是在检查你对知识的掌握情况。凡是考前做过书本题目或者往年试卷（考试原题大多来源于此），考个高分真的不是问题（这方面有可能跟学校的 level 有关吧）。可是，这样做的意义又何在呢？高中时，考试的确是要“分秒必争”，可是到了大学我觉得在学习这方面最重要的是独立思考与实事求是。倘若只是考试得了个高分而对知识的理解仅仅浮于表面，那么你除了 GPA 和奖学金这些外物，其它一无所获。如果在大学里玩弄仍然是高中那一套，那读大学岂不是与不读无异？</li><li>半衰期长与短的问题。这就涉及到很多方面了，不同学科之间也存在这个问题。就拿贵院的软件工程专业的“数据结构”和“ Android 开发”这两门课来讲，“数据结构”作为计算机类专业的基础学科，其半衰期就比“ Android 开发”长，那么明智的做法就是在学习过程中，在“数据结构”这门课上投入更多的精力。而在考试这方面，我觉得花时间使劲做题去争取高分的半衰期短得可怜。（虽然 GPA 也有用，但是我觉得很多东西用 GPA 来量化也是非常不科学的……）</li></ol><p>总的来说，我认为很多人对待期末考试的态度过于急功近利，反倒是那些只玩游戏其它啥都不 care 的同学活得比较单纯些……</p><p>最后，由衷感谢贵院的试卷和老师的努力使我成功地通过了各项考试……</p><h2 id="驾考"><a href="#驾考" class="headerlink" title="驾考"></a>驾考</h2><p>考完试回家以后，就开始忙家里的事，忙完之后又去学车考证。可以说一回到家之后就没停过，好在昨天成功通过科目三、四，拿到了驾照。驾考本身套路多我就不多说了……</p><p>以后自己就能开车上路了，想想还有点小激动……</p><p>How many roads must an driver drive down before you call him an old driver ? 🙊</p><h2 id="✨"><a href="#✨" class="headerlink" title="✨"></a>✨</h2><p>不过总算有自己的时间了，还有很多事情要做。</p><p>BTW，下学期 β-house 在青山湖终于要有办公室了，期待！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有人说，每年年度总结定下的未来计划都是去年年度总结中定下的，就这样一年复一年，自己的“一年计划”从未实现。&lt;/p&gt;
&lt;p&gt;我也没有在 2016 年度总结给我自己定下什么计划或者什么小目标，只是给自己定个方向，比如说多写博文、多看书等，期望自己能够有意识的往这个方向去靠。计划
      
    
    </summary>
    
      <category term="♥" scheme="http://zhoushidong.cc/categories/%E2%99%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>my 2016</title>
    <link href="http://zhoushidong.cc/2016/12/30/my-2016/"/>
    <id>http://zhoushidong.cc/2016/12/30/my-2016/</id>
    <published>2016-12-30T09:21:38.000Z</published>
    <updated>2017-02-22T10:09:29.764Z</updated>
    
    <content type="html"><![CDATA[<p>2016这一年，大事件很多。当你无聊地刷着社交媒体时，你会发现这个世界会动不动给你来个大新闻。就在前几天，《星球大战》莱亚公主扮演者 Carrie Fisher 去世，随后一天，其母 Debbie Reynolds 去世，仿佛死神在冲刺年终奖……总体来讲，2016年对于整个世界来说绝对是 a piece of shit。</p><p>而对于我自己来讲，2016 也没有糟糕至如此地步，至少自己的生活里多了 β-house。</p><h2 id="β-house"><a href="#β-house" class="headerlink" title="β-house"></a>β-house</h2><p>加入 β-house 工作室是我今年做的最有意义的一件事，也非常荣幸能被师兄师姐们录取。</p><p>上半年，参加 β-house 的每周例会，每周六上午十点出发去下沙，学习了不少干货，再于夜幕降临之际回到文一。那段经历注定是难忘的。</p><blockquote><p>程序员的正式称号是 SDE——Software Development Engineer。但其真正的名字：Someone (Who Can) Do Everything.</p></blockquote><p>这是 β-house 招新时的标语。β-house 就如一个引路人，它有一种说不出的特质能够触动你去 create something.</p><p>下半年就搬去新校区了，与工作室的前辈们接触不多，但仍甚是想念。没过多久，下沙的 222 办公室因学院搬迁被清空，炳哥、大表哥也即将毕业，“别离”果然是人们无法回避的一个过程。</p><p><a href="https://oblky3j33.qnssl.com//beta/14.jpg" target="_blank" rel="noopener"><img src="https://oblky3j33.qnssl.com//beta/14.jpg" alt="222 办公室"></a>222 办公室</p><h2 id="除此之外"><a href="#除此之外" class="headerlink" title="除此之外"></a>除此之外</h2><p>新校区，在“无车马喧”的临安青山湖。青山环绕，空气清新，看起来像是一个静心的地方。为了 β-house 在新校区的办公室问题，也折腾了不少时间。刚开始真是处处碰壁，差点以为办公室真的没着落了。后来跟学校达成协议，跟以前一样，首先帮学校干点活(会给点经费)。有一点没想到，那就是刚开始引起学校注意的是我一个写着玩的爬虫项目（就是把教务系统的课表数据抓取下来，集成到微信公众号上）。当时因为教务信息搬迁，像超级课程表这样的第三方软件都爬取不了课表，只有我们工作室能做😎。后来给学校做事，就放在了学生会的微信号上，后续还做了考试安排等功能……</p><p><a href="https://camo.githubusercontent.com/19f08df16ec431ac1a2edeb94779622f6c3212a8/687474703a2f2f6f366c6a77387763712e626b742e636c6f7564646e2e636f6d2f494d475f323438395f496e6b5f4c492d6d696e2e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/19f08df16ec431ac1a2edeb94779622f6c3212a8/687474703a2f2f6f366c6a77387763712e626b742e636c6f7564646e2e636f6d2f494d475f323438395f496e6b5f4c492d6d696e2e6a7067" alt="img"></a>img</p><p>其实到了大学，我们遇到的很多事情都是“利益相关”了，不仅仅是跟向学校要办公室这件事，也包括同学和同学之间的人际交往。你拿出一部分利益给他人，你自然而然能够得到他人所拥有的一些资源。很多人际关系的建立就是从一些“小交易”开始的，非常现实。</p><p>说到人际交往，到目前为止我在大学就没有关系非常铁的朋友，意趣相投的朋友真的是可遇不可求。</p><p>除了加入 β-house，似乎在我身上就再也没有发生什么特别值得纪念的大事件。真的。</p><p>《西部世界》中，每个机器人在真正觉醒之前都陷在自己的 loop 中，被人类玩弄致死，再被清空记忆而“重生”。我感觉自己也是陷在 loop 里面。记得在高考完当天，我曾经发过这样一条朋友圈：</p><p><a href="http://o6ljw8wcq.bkt.clouddn.com/asdasd.png" target="_blank" rel="noopener"><img src="http://o6ljw8wcq.bkt.clouddn.com/asdasd.png" alt="string"></a>string</p><p>我原以为自己不会再被一些东西束缚，但其实我是从一个 loop 跳入了另一个 loop。我感觉到自己是浮躁的，这种浮躁从高中开始就有了，没变过。从某种程度上来看，好像是我自己束缚着自己。我觉得自己需要一些改变。并不是“来一场说走就走的旅行”的那种改变，是真的需要静下心来好好想明白一些事情。</p><h2 id="我需要什么？"><a href="#我需要什么？" class="headerlink" title="我需要什么？"></a>我需要什么？</h2><p>机缘巧合，得到机会去了解了一下一个学院大力支持的创业项目，方向正是现在热炒的“互联网+大学生创业”。然后我发现，这种项目其实全国各地都有很多人在做，而且做的人都是大学生。后来我又去深入了解了一下目前中国大学生的创业项目，发现很多产品之前都有两个共同点：</p><ol><li>面向大学生，基于校园</li><li>模式相似，可复制</li><li>短命</li></ol><p>大概第三点的原因就是前两点吧……</p><p>网上曾经有人这样吐槽大学生创业：</p><blockquote><p>你把好几个大学生关在屋子里想好几天，最后能写下来的点子也无非就是那些什么奶茶礼品送外卖、漫吧桌游代金券，花店书店咖啡馆一类的东西。能想到的都是校园和校园衍生的那些玩意儿。什么服务大学寝室的送餐啦，用来给大学生把妹的课程表啦，帮社团搞印刷品纪念品啦，跑到大学后门一条街去发传单啦，联系校园附近的商家打广告啦。</p></blockquote><p>视野狭窄导致这些大学生做出来的东西没有核心竞争力，他做的东西别人也可以做。Bill Gates 在哈佛的时候，为第一台微型计算机 MITS Altair开发了 BASIC 编程语言的一个版本。这东西可不是其他人随随便便就能做出来的，这就是他的核心竞争力。</p><p>我需要培养自己的核心竞争力，这是我在 2016 年学到的比较重要的一点。</p><h2 id="TODO：把一些丢掉的东西捡起来"><a href="#TODO：把一些丢掉的东西捡起来" class="headerlink" title="TODO：把一些丢掉的东西捡起来"></a>TODO：把一些丢掉的东西捡起来</h2><p>我丢掉了什么？</p><ol><li><p>读书（非技术书）的习惯</p><p>其实这个习惯我在初中的时候就丢掉了。小学毕业之后，我似乎没有真正意义上地读完过一本好书。说起来真的好惭愧啊，至少我在小学的时候还读过《哈利波特》全套呢。初中的时候忙着中二，没读。高中的时候读的都是些消遣性的杂志。这个念头是我在逛一个程序媛的博客的时候产生的。她不仅代码写得好，文笔也极佳，而且每读完一本书就会写一篇读后感博文，我真的十分佩服她。看书究竟有什么用，我也说不出来。但或许有时候人就是需要这种“无用”的积累，才能解决诸如“loop”这样的问题。</p></li><li><p>发表、记录自己的想法</p><p>今年三月份我就开了博客，一开始志气满满，誓要经常写博文，然而算上这一篇整个博客中也不过七篇文章（不过还是吸引到了一位网友来此留言🙉）明年开始，要增加写博文的频率。</p><p>另外 ，我向来喜欢在各种社区中潜水，遇到技术问题也很少提问，别人撕逼的时候我也只是在一旁围观。我决定以后要在社区中多发言，甚至可以参加一场撕逼，这样的思想碰撞说不定能使自己的思路更加开阔……</p></li></ol><h2 id="不知谁能躲得过去"><a href="#不知谁能躲得过去" class="headerlink" title="不知谁能躲得过去"></a>不知谁能躲得过去</h2><p>我从来没有过诸如“我对这一天/这一年比较满意”这样的想法。我总觉得这一天/这一年还缺少一点什么，总觉得生活也不是那么美好。</p><p>每逢元旦，我的心情一般都不是很好，因为一年过去，历史的进程在大步向前推进，即使我也做了点微小的工作，但总是无法避免身边的事物的流逝。这种问题，谁能躲得过去呢？所有，一定要好好珍惜眼前所拥有的一切。</p><p>写的比较乱，最后简单说两句：</p><blockquote><p>“…似乎在我身上就再也没有发生什么特别值得纪念的大事件”</p></blockquote><p>我还是很好奇未来会发生什么事，会遇见哪些有意思的人的……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2016这一年，大事件很多。当你无聊地刷着社交媒体时，你会发现这个世界会动不动给你来个大新闻。就在前几天，《星球大战》莱亚公主扮演者 Carrie Fisher 去世，随后一天，其母 Debbie Reynolds 去世，仿佛死神在冲刺年终奖……总体来讲，2016年对于整个
      
    
    </summary>
    
      <category term="♥" scheme="http://zhoushidong.cc/categories/%E2%99%A5/"/>
    
    
      <category term="年度总结" scheme="http://zhoushidong.cc/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
